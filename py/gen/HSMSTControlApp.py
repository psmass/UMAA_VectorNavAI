#!/bin/env python 

# HSMSTControlApp.py
# A generated example that uses XML Application Creation with 
# Dynamic Data.
#
# This code is automatically generated by RTI System Designer.
# Any change will be overwritten if the file is re-generated.

import argparse
import random
import string
import time
import sys
from dataclasses import dataclass

import rti.connextdds as dds

XML_FILENAME = "HSMSTControlApp.xml"



# App
# ----------------------------------------------------------------------------
# The main application containing all the DDS Entities. 
class App(dds.NoOpDomainParticipantListener):
    def __init__(self, xml_filename, participant_name):
        super().__init__()
        self._qos_provider = dds.QosProvider(xml_filename)
        self._participant  = self._qos_provider.create_participant_from_config(participant_name)
        self._participant.set_listener(self, dds.StatusMask.ALL & dds.StatusMask.flip(dds.StatusMask.DATA_ON_READERS))


        # DataReader(s):
        self._waitset = dds.WaitSet()
        self._global_pose_reader_dr = dds.DynamicData.DataReader(self._participant.find_datareader("HSMSTControlSubscriber::GlobalPoseReader"))
        self._global_pose_reader_dr_read_count = 0
        self._global_pose_reader_dr_read_condition = dds.ReadCondition(
                self._global_pose_reader_dr, 
                dds.DataState.any, 
                lambda _: self.read_global_pose_reader_dr())
        self._waitset += self._global_pose_reader_dr_read_condition

        self._speed_reader_dr = dds.DynamicData.DataReader(self._participant.find_datareader("HSMSTControlSubscriber::SpeedReader"))
        self._speed_reader_dr_read_count = 0
        self._speed_reader_dr_read_condition = dds.ReadCondition(
                self._speed_reader_dr, 
                dds.DataState.any, 
                lambda _: self.read_speed_reader_dr())
        self._waitset += self._speed_reader_dr_read_condition




    def read_global_pose_reader_dr(self):
        samples = self._global_pose_reader_dr.take_data()
        for sample in samples:
            self._global_pose_reader_dr_read_count += 1
            print(f"[HSMSTControlSubscriber_GlobalPoseReader] Received sample #{self._global_pose_reader_dr_read_count}:")
            print(sample)
    def read_speed_reader_dr(self):
        samples = self._speed_reader_dr.take_data()
        for sample in samples:
            self._speed_reader_dr_read_count += 1
            print(f"[HSMSTControlSubscriber_SpeedReader] Received sample #{self._speed_reader_dr_read_count}:")
            print(sample)

    # Runs the main application spin loop. Returns the process exit code.
    def run(self, period_microsec, max_iterations, max_keys):
        print("Application is starting. Press CTRL+C to stop")
        count = 0
        wait_microsec = 0
        while ((max_iterations == -1) or (count < max_iterations)):
            print(f"Running iteration #{count}")
            if (wait_microsec <= 0):
                wait_microsec = period_microsec
                count += 1
            t1 = self._participant.current_time.to_microseconds()
            self._waitset.dispatch(dds.Duration.from_microseconds(wait_microsec))
            wait_microsec -= (self._participant.current_time.to_microseconds() - t1)
 
    # Default implementation of DataReaderListener callbacks unless overwritten
    def on_requested_deadline_missed(self, reader, status):
        print(f"on_requested_deadline_missed: topic=#{reader.topic_name}")

    def on_requested_incompatible_qos(self, reader, status):
        print(f"on_requested_incompatible_qos: topic=#{reader.topic_name}")

    def on_sample_rejected(self, reader, status):
        print(f"on_sample_rejected: topic=#{reader.topic_name}")

    def on_liveliness_changed(self, reader, status):
        print(f"on_liveliness_changed: topic=#{reader.topic_name}")

    def on_sample_lost(self, reader, status):
        print(f"on_sample_lost: topic=#{reader.topic_name}")

    def on_subscription_matched(self, reader, status):
        print(f"on_subscription_matched: topic=#{reader.topic_name}")
    # End of Default DataReaderListener callbacks

    # Default DataWriterListener callbacks
    def on_offered_deadline_missed(self, writer, status):
        print(f"on_offered_deadline_missed: topic=#{writer.topic_name}")

    def on_liveliness_lost(self, writer, status):
        print(f"on_liveliness_lost: topic=#{writer.topic_name}")
    
    def on_offered_incompatible_qos(self, writer, status):
        print(f"on_offered_incompatible_qos: topic=#{writer.topic_name}")

    def on_publication_matched(self, writer, status):
        print(f"on_publication_matched: topic=#{writer.topic_name}, match count=#{status.current_count}")


# A data class to store the parsed command line arguments
# -----------------------------------------------------------------------------
@dataclass
class ApplicationArguments:
    loop_period_msec = 1000
    max_iterations = -1
    max_key_count = 10

# parse_arguments
# -----------------------------------------------------------------------------
# parses the command line arguments and returns an ApplicationArguments object
def parse_arguments():
    parser = argparse.ArgumentParser(description='HSMSTControlApp Connext DDS Application')
    parser.add_argument(
        '-l',
        '--loop_period_msec',
        type=int,
        help='Number of milliseconds to wait in main spin loop')
    parser.add_argument(
        '-i',
        '--max_iterations',
        type=int,
        help='Number iterations to perform before terminating (-1=unlimited)')
    parser.add_argument(
        '-k',
        '--max_key_count',
        type=int,
        help='Number keys to use when publishing data')
    return parser.parse_args(namespace=ApplicationArguments)


# Main entry point
# -----------------------------------------------------------------------------
def main():
    args: ApplicationArguments = parse_arguments()
    try:
        app = App(XML_FILENAME, "UMAA_DomainParticipantLibrary::UMAA_DomainParticipantLibrary::HSMSTControlParticipant")
        app.run(args.loop_period_msec*1000, args.max_iterations, args.max_key_count)

    except KeyboardInterrupt:
        print("Shutting down...")

# Main
if __name__ == '__main__':
    main()



